netcdf ini_blank {
dimensions:
	xi_rho = 12 ;
	xi_u = 11 ;
	xi_v = 12 ;
	xi_psi = 11 ;
	eta_rho = 14 ;
	eta_u = 14 ;
	eta_v = 13 ;
	eta_psi = 13 ;
	N = 400 ;
	s_rho = NDEPTHS_RHO ;
	s_w = NDEPTHS_W ;
	tracer = 2 ;
	boundary = 4 ;
	ocean_time = 1 ; // (1 currently)
variables:
	int ntimes ;
		ntimes:long_name = "number of long time-steps" ;
	int ndtfast ;
		ndtfast:long_name = "number of short time-steps" ;
	double dt ;
		dt:long_name = "size of long time-steps" ;
		dt:units = "second" ;
	double dtfast ;
		dtfast:long_name = "size of short time-steps" ;
		dtfast:units = "second" ;
	double dstart ;
		dstart:long_name = "time stamp assigned to model initilization" ;
		dstart:units = "days since 1970-01-01 00:00:00" ;
		dstart:calendar = "proleptic_gregorian" ;
	int nHIS ;
		nHIS:long_name = "number of time-steps between history records" ;
	int ndefHIS ;
		ndefHIS:long_name = "number of time-steps between the creation of history files" ;
	int nRST ;
		nRST:long_name = "number of time-steps between restart records" ;
		nRST:cycle = "only latest two records are maintained" ;
	double Falpha ;
		Falpha:long_name = "Power-law shape barotropic filter parameter" ;
	double Fbeta ;
		Fbeta:long_name = "Power-law shape barotropic filter parameter" ;
	double Fgamma ;
		Fgamma:long_name = "Power-law shape barotropic filter parameter" ;
	double Akt_bak(tracer) ;
		Akt_bak:long_name = "background vertical mixing coefficient for tracers" ;
		Akt_bak:units = "meter2 second-1" ;
	double Akv_bak ;
		Akv_bak:long_name = "background vertical mixing coefficient for momentum" ;
		Akv_bak:units = "meter2 second-1" ;
	double rdrg ;
		rdrg:long_name = "linear drag coefficient" ;
		rdrg:units = "meter second-1" ;
	double rdrg2 ;
		rdrg2:long_name = "quadratic drag coefficient" ;
	double Zob ;
		Zob:long_name = "bottom roughness" ;
		Zob:units = "meter" ;
	double Zos ;
		Zos:long_name = "surface roughness" ;
		Zos:units = "meter" ;
	double Znudg ;
		Znudg:long_name = "free-surface nudging/relaxation inverse time scale" ;
		Znudg:units = "day-1" ;
	double M2nudg ;
		M2nudg:long_name = "2D momentum nudging/relaxation inverse time scale" ;
		M2nudg:units = "day-1" ;
	double M3nudg ;
		M3nudg:long_name = "3D momentum nudging/relaxation inverse time scale" ;
		M3nudg:units = "day-1" ;
	double Tnudg(tracer) ;
		Tnudg:long_name = "Tracers nudging/relaxation inverse time scale" ;
		Tnudg:units = "day-1" ;
	double rho0 ;
		rho0:long_name = "mean density used in Boussinesq approximation" ;
		rho0:units = "kilogram meter-3" ;
	double gamma2 ;
		gamma2:long_name = "slipperiness parameter" ;
	int LuvSrc ;
		LuvSrc:long_name = "momentum point sources and sink activation switch" ;
		LuvSrc:flag_values = 0, 1 ;
		LuvSrc:flag_meanings = ".FALSE. .TRUE." ;
	int LwSrc ;
		LwSrc:long_name = "mass point sources and sink activation switch" ;
		LwSrc:flag_values = 0, 1 ;
		LwSrc:flag_meanings = ".FALSE. .TRUE." ;
	int LtracerSrc(tracer) ;
		LtracerSrc:long_name = "tracer point sources and sink activation switch" ;
		LtracerSrc:flag_values = 0, 1 ;
		LtracerSrc:flag_meanings = ".FALSE. .TRUE." ;
	int LsshCLM ;
		LsshCLM:long_name = "sea surface height climatology processing switch" ;
		LsshCLM:flag_values = 0, 1 ;
		LsshCLM:flag_meanings = ".FALSE. .TRUE." ;
	int Lm2CLM ;
		Lm2CLM:long_name = "2D momentum climatology processing switch" ;
		Lm2CLM:flag_values = 0, 1 ;
		Lm2CLM:flag_meanings = ".FALSE. .TRUE." ;
	int Lm3CLM ;
		Lm3CLM:long_name = "3D momentum climatology processing switch" ;
		Lm3CLM:flag_values = 0, 1 ;
		Lm3CLM:flag_meanings = ".FALSE. .TRUE." ;
	int LtracerCLM(tracer) ;
		LtracerCLM:long_name = "tracer climatology processing switch" ;
		LtracerCLM:flag_values = 0, 1 ;
		LtracerCLM:flag_meanings = ".FALSE. .TRUE." ;
	int LnudgeM2CLM ;
		LnudgeM2CLM:long_name = "2D momentum climatology nudging activation switch" ;
		LnudgeM2CLM:flag_values = 0, 1 ;
		LnudgeM2CLM:flag_meanings = ".FALSE. .TRUE." ;
	int LnudgeM3CLM ;
		LnudgeM3CLM:long_name = "3D momentum climatology nudging activation switch" ;
		LnudgeM3CLM:flag_values = 0, 1 ;
		LnudgeM3CLM:flag_meanings = ".FALSE. .TRUE." ;
	int LnudgeTCLM(tracer) ;
		LnudgeTCLM:long_name = "tracer climatology nudging activation switch" ;
		LnudgeTCLM:flag_values = 0, 1 ;
		LnudgeTCLM:flag_meanings = ".FALSE. .TRUE." ;
	int spherical ;
		spherical:long_name = "grid type logical switch" ;
		spherical:flag_values = 0, 1 ;
		spherical:flag_meanings = "Cartesian spherical" ;
	double xl ;
		xl:long_name = "domain length in the XI-direction" ;
		xl:units = "meter" ;
	double el ;
		el:long_name = "domain length in the ETA-direction" ;
		el:units = "meter" ;
	int Vtransform ;
		Vtransform:long_name = "vertical terrain-following transformation equation" ;
	int Vstretching ;
		Vstretching:long_name = "vertical terrain-following stretching function" ;
	double theta_s ;
		theta_s:long_name = "S-coordinate surface control parameter" ;
	double theta_b ;
		theta_b:long_name = "S-coordinate bottom control parameter" ;
	double Tcline ;
		Tcline:long_name = "S-coordinate surface/bottom layer width" ;
		Tcline:units = "meter" ;
	double hc ;
		hc:long_name = "S-coordinate parameter, critical depth" ;
		hc:units = "meter" ;
	int grid ;
		grid:cf_role = "grid_topology" ;
		grid:topology_dimension = 2 ;
		grid:node_dimensions = "xi_psi eta_psi" ;
		grid:face_dimensions = "xi_rho: xi_psi (padding: both) eta_rho: eta_psi (padding: both)" ;
		grid:edge1_dimensions = "xi_u: xi_psi eta_u: eta_psi (padding: both)" ;
		grid:edge2_dimensions = "xi_v: xi_psi (padding: both) eta_v: eta_psi" ;
		grid:node_coordinates = "x_psi y_psi" ;
		grid:face_coordinates = "x_rho y_rho" ;
		grid:edge1_coordinates = "x_u y_u" ;
		grid:edge2_coordinates = "x_v y_v" ;
		grid:vertical_dimensions = "s_rho: s_w (padding: none)" ;
	double s_rho(s_rho) ;
		s_rho:long_name = "S-coordinate at RHO-points" ;
		s_rho:valid_min = -1. ;
		s_rho:valid_max = 0. ;
		s_rho:positive = "up" ;
		s_rho:standard_name = "ocean_s_coordinate_g2" ;
		s_rho:formula_terms = "s: s_rho C: Cs_r eta: zeta depth: h depth_c: hc" ;
		s_rho:field = "s_rho, scalar" ;
	double s_w(s_w) ;
		s_w:long_name = "S-coordinate at W-points" ;
		s_w:valid_min = -1. ;
		s_w:valid_max = 0. ;
		s_w:positive = "up" ;
		s_w:standard_name = "ocean_s_coordinate_g2" ;
		s_w:formula_terms = "s: s_w C: Cs_w eta: zeta depth: h depth_c: hc" ;
		s_w:field = "s_w, scalar" ;
	double Cs_r(s_rho) ;
		Cs_r:long_name = "S-coordinate stretching curves at RHO-points" ;
		Cs_r:valid_min = -1. ;
		Cs_r:valid_max = 0. ;
		Cs_r:field = "Cs_r, scalar" ;
	double Cs_w(s_w) ;
		Cs_w:long_name = "S-coordinate stretching curves at W-points" ;
		Cs_w:valid_min = -1. ;
		Cs_w:valid_max = 0. ;
		Cs_w:field = "Cs_w, scalar" ;
	double h(eta_rho, xi_rho) ;
		h:long_name = "bathymetry at RHO-points" ;
		h:units = "meter" ;
		h:grid = "grid" ;
		h:location = "face" ;
		h:coordinates = "x_rho y_rho" ;
		h:field = "bath, scalar" ;
	double f(eta_rho, xi_rho) ;
		f:long_name = "Coriolis parameter at RHO-points" ;
		f:units = "second-1" ;
		f:grid = "grid" ;
		f:location = "face" ;
		f:coordinates = "x_rho y_rho" ;
		f:field = "coriolis, scalar" ;
	double pm(eta_rho, xi_rho) ;
		pm:long_name = "curvilinear coordinate metric in XI" ;
		pm:units = "meter-1" ;
		pm:grid = "grid" ;
		pm:location = "face" ;
		pm:coordinates = "x_rho y_rho" ;
		pm:field = "pm, scalar" ;
	double pn(eta_rho, xi_rho) ;
		pn:long_name = "curvilinear coordinate metric in ETA" ;
		pn:units = "meter-1" ;
		pn:grid = "grid" ;
		pn:location = "face" ;
		pn:coordinates = "x_rho y_rho" ;
		pn:field = "pn, scalar" ;
	double x_rho(eta_rho, xi_rho) ;
		x_rho:long_name = "x-locations of RHO-points" ;
		x_rho:units = "meter" ;
		x_rho:field = "x_rho, scalar" ;
	double y_rho(eta_rho, xi_rho) ;
		y_rho:long_name = "y-locations of RHO-points" ;
		y_rho:units = "meter" ;
		y_rho:field = "y_rho, scalar" ;
	double x_u(eta_u, xi_u) ;
		x_u:long_name = "x-locations of U-points" ;
		x_u:units = "meter" ;
		x_u:field = "x_u, scalar" ;
	double y_u(eta_u, xi_u) ;
		y_u:long_name = "y-locations of U-points" ;
		y_u:units = "meter" ;
		y_u:field = "y_u, scalar" ;
	double x_v(eta_v, xi_v) ;
		x_v:long_name = "x-locations of V-points" ;
		x_v:units = "meter" ;
		x_v:field = "x_v, scalar" ;
	double y_v(eta_v, xi_v) ;
		y_v:long_name = "y-locations of V-points" ;
		y_v:units = "meter" ;
		y_v:field = "y_v, scalar" ;
	double x_psi(eta_psi, xi_psi) ;
		x_psi:long_name = "x-locations of PSI-points" ;
		x_psi:units = "meter" ;
		x_psi:field = "x_psi, scalar" ;
	double y_psi(eta_psi, xi_psi) ;
		y_psi:long_name = "y-locations of PSI-points" ;
		y_psi:units = "meter" ;
		y_psi:field = "y_psi, scalar" ;
	double ocean_time(ocean_time) ;
		ocean_time:long_name = "time since initialization" ;
		ocean_time:units = "seconds since 1970-01-01 00:00:00" ;
		ocean_time:field = "time, scalar, series" ;
	double zeta(ocean_time, eta_rho, xi_rho) ;
		zeta:long_name = "free-surface" ;
		zeta:units = "meter" ;
		zeta:time = "ocean_time" ;
		zeta:grid = "grid" ;
		zeta:location = "face" ;
		zeta:coordinates = "x_rho y_rho ocean_time" ;
		zeta:field = "free-surface, scalar, series" ;
	double ubar(ocean_time, eta_u, xi_u) ;
		ubar:long_name = "vertically integrated u-momentum component" ;
		ubar:units = "meter second-1" ;
		ubar:time = "ocean_time" ;
		ubar:grid = "grid" ;
		ubar:location = "edge1" ;
		ubar:coordinates = "x_u y_u ocean_time" ;
		ubar:field = "ubar-velocity, scalar, series" ;
	double vbar(ocean_time, eta_v, xi_v) ;
		vbar:long_name = "vertically integrated v-momentum component" ;
		vbar:units = "meter second-1" ;
		vbar:time = "ocean_time" ;
		vbar:grid = "grid" ;
		vbar:location = "edge2" ;
		vbar:coordinates = "x_v y_v ocean_time" ;
		vbar:field = "vbar-velocity, scalar, series" ;
	double u(ocean_time, s_rho, eta_u, xi_u) ;
		u:long_name = "u-momentum component" ;
		u:units = "meter second-1" ;
		u:time = "ocean_time" ;
		u:grid = "grid" ;
		u:location = "edge1" ;
		u:coordinates = "x_u y_u s_rho ocean_time" ;
		u:field = "u-velocity, scalar, series" ;
	double v(ocean_time, s_rho, eta_v, xi_v) ;
		v:long_name = "v-momentum component" ;
		v:units = "meter second-1" ;
		v:time = "ocean_time" ;
		v:grid = "grid" ;
		v:location = "edge2" ;
		v:coordinates = "x_v y_v s_rho ocean_time" ;
		v:field = "v-velocity, scalar, series" ;
	double temp(ocean_time, s_rho, eta_rho, xi_rho) ;
		temp:long_name = "potential temperature" ;
		temp:units = "Celsius" ;
		temp:time = "ocean_time" ;
		temp:grid = "grid" ;
		temp:location = "face" ;
		temp:coordinates = "x_rho y_rho s_rho ocean_time" ;
		temp:field = "temperature, scalar, series" ;
	double salt(ocean_time, s_rho, eta_rho, xi_rho) ;
		salt:long_name = "salinity" ;
		salt:time = "ocean_time" ;
		salt:grid = "grid" ;
		salt:location = "face" ;
		salt:coordinates = "x_rho y_rho s_rho ocean_time" ;
		salt:field = "salinity, scalar, series" ;
	double rho(ocean_time, s_rho, eta_rho, xi_rho) ;
		rho:long_name = "density anomaly" ;
		rho:units = "kilogram meter-3" ;
		rho:time = "ocean_time" ;
		rho:grid = "grid" ;
		rho:location = "face" ;
		rho:coordinates = "x_rho y_rho s_rho ocean_time" ;
		rho:field = "density, scalar, series" ;
	double Hsbl(ocean_time, eta_rho, xi_rho) ;
		Hsbl:long_name = "depth of oceanic surface boundary layer" ;
		Hsbl:units = "meter" ;
		Hsbl:time = "ocean_time" ;
		Hsbl:grid = "grid" ;
		Hsbl:location = "face" ;
		Hsbl:coordinates = "x_rho y_rho ocean_time" ;
		Hsbl:field = "Hsbl, scalar, series" ;
	double Hbbl(ocean_time, eta_rho, xi_rho) ;
		Hbbl:long_name = "depth of oceanic bottom boundary layer" ;
		Hbbl:units = "meter" ;
		Hbbl:time = "ocean_time" ;
		Hbbl:grid = "grid" ;
		Hbbl:location = "face" ;
		Hbbl:coordinates = "x_rho y_rho ocean_time" ;
		Hbbl:field = "Hbbl, scalar, series" ;
	double AKv(ocean_time, s_w, eta_rho, xi_rho) ;
		AKv:long_name = "vertical viscosity coefficient" ;
		AKv:units = "meter2 second-1" ;
		AKv:time = "ocean_time" ;
		AKv:grid = "grid" ;
		AKv:location = "face" ;
		AKv:coordinates = "x_rho y_rho s_w ocean_time" ;
		AKv:field = "AKv, scalar, series" ;
	double AKt(ocean_time, s_w, eta_rho, xi_rho) ;
		AKt:long_name = "temperature vertical diffusion coefficient" ;
		AKt:units = "meter2 second-1" ;
		AKt:time = "ocean_time" ;
		AKt:grid = "grid" ;
		AKt:location = "face" ;
		AKt:coordinates = "x_rho y_rho s_w ocean_time" ;
		AKt:field = "AKt, scalar, series" ;
	double AKs(ocean_time, s_w, eta_rho, xi_rho) ;
		AKs:long_name = "salinity vertical diffusion coefficient" ;
		AKs:units = "meter2 second-1" ;
		AKs:time = "ocean_time" ;
		AKs:grid = "grid" ;
		AKs:location = "face" ;
		AKs:coordinates = "x_rho y_rho s_w ocean_time" ;
		AKs:field = "AKs, scalar, series" ;

// global attributes:
		:file = "roms_rst.nc" ;
		:format = "netCDF-3 64bit offset file" ;
		:Conventions = "CF-1.4, SGRID-0.3" ;
		:type = "ROMS/TOMS restart file" ;
		:title = "Column model for turbulence scheme testing" ;
		:var_info = "../External/varinfo.dat" ;
		:rst_file = "roms_rst.nc" ;
		:frc_file_01 = "roms_frc.nc" ;
		:NLM_LBC = "\n",
			"EDGE:  WEST   SOUTH  EAST   NORTH  \n",
			"zeta:  Per    Per    Per    Per    \n",
			"ubar:  Per    Per    Per    Per    \n",
			"vbar:  Per    Per    Per    Per    \n",
			"u:     Per    Per    Per    Per    \n",
			"v:     Per    Per    Per    Per    \n",
			"temp:  Per    Per    Per    Per    \n",
			"salt:  Per    Per    Per    Per" ;
		:svn_url = "https://www.myroms.org/svn/src/trunk" ;
		:svn_rev = "986" ;
		:code_dir = "/home/kaihc/ROMS-trunk" ;
		:header_dir = "/home/kaihc/Desktop/romsmix/Include" ;
		:header_file = "column.h" ;
		:os = "Linux" ;
		:cpu = "x86_64" ;
		:compiler_system = "gfortran" ;
		:compiler_command = "/usr/bin/gfortran" ;
		:compiler_flags = "-frepack-arrays -O3 -ffast-math -" ;
		:tiling = "001x001" ;
		:history = "ROMS/TOMS, Version 3.8, Friday - January 24, 2020 - 10:08:32 PM" ;
		:ana_file = "ROMS/Functionals/ana_btflux.h, /home/kaihc/Desktop/romsmix/Include/ana_grid.h, ROMS/Functionals/ana_initial.h" ;
		:CPP_options = "COLUMN, ANA_BSFLUX, ANA_BTFLUX, ANA_GRID, ANA_INITIAL, ASSUMED_SHAPE, DJ_GRADPS, DOUBLE_PRECISION, LMD_BKPP, LMD_CONVEC, LMD_DDMIX, LMD_MIXING, LMD_NONLOCAL, LMD_RIMIX, LMD_SKPP, NONLINEAR, NONLIN_EOS, POWER_LAW, PROFILE, RI_SPLINES, !RST_SINGLE, SALINITY, SOLVE3D, SPLINES_VDIFF, SPLINES_VVISC, TS_C4HADVECTION, TS_C4VADVECTION, UV_COR, UV_QDRAG, VAR_RHO_2D" ;
}
